import os, struct, time
from  mersenne_twister import MersenneTwister

def xor(s1, s2):
	return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(s1, s2)])

def encrypt(message, seed):
	mt = MersenneTwister(seed)
	return ''.join([chr(ord(m) ^ (mt.extract_number() % 256)) for m in message])

def decrypt(message, seed):
	return encrypt(message, seed)

def random_int16():
	return struct.unpack("!H", os.urandom(2))[0]

def get_ct(known_pt):
	prefix_len = ord(os.urandom(1))
	prefix = os.urandom(prefix_len)
	key = random_int16()
	return encrypt(prefix + known_pt, key)

def skip_output(mt, n):
	'''skips the first n outputs of mt'''
	mt.twist()
	#skip the extract number step for faster skipping
	while n >= 624:
		mt.twist()
		n -= 624
	mt.index = n

def recover_key(known_pt, ct):
	prefix_len = len(ct) - len(known_pt)
	partial_key = xor(known_pt, ct[prefix_len:])

	#try all partial 16 bit seeds
	for i in range((1<<16)):
		mt = MersenneTwister(i)
		skip_output(mt, prefix_len)

		match = True
		#check to see if output matches
		for c in partial_key:
			if ord(c) != (mt.extract_number() % 256):
				match = False
				break
		if match:
			return i

#seeds with current time
def get_token(seed=int(time.time())):
	mt = MersenneTwister(seed)
	return ''.join([chr(mt.extract_number() % 256) for _ in range(8)])

def check_token(token):
	now = int(time.time())
	#check 2 minute window
	for s in range(now - 60, now + 60):
		if get_token(s) == token:
			return True
	return False

#seeds with current time generates random number of tokens and returns last
#one generated
def get_token2():
	mt = MersenneTwister(int(time.time()))
	skip_output(mt, random_int16())
	return [chr(mt.extract_number() % 256) for _ in range(8)]

#checks if token in in the first max_output bytes of the stream
#generated by seed
def is_in_stream(seed, token, max_output):
	mt = MersenneTwister(seed)
	stream = []
	#get full token worth to compare with
	while len(stream) < len(token):
		stream.append(chr(mt.extract_number() % 256))

	if stream == token: return True
	
	max_output -= len(stream)
	i = 0
	while i < max_output:
		stream.pop(0)
		stream.append(chr(mt.extract_number() % 256))
		if stream == token: return True
		i += 1
	return False

def check_token2(token, window_size):
	now = int(time.time())
	for t in range(now - window_size, now + (window_size >> 2)):
		if is_in_stream(t, token, (1<<16)):
			return True
	return False
